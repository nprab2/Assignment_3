# -*- coding: utf-8 -*-
"""Final Assignment3_Final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10VZAH2EPkeLdxwKGSDF_IJy0-AaDDrwF

# Assignment 3: Integer Programming Example---Algorithmic Redistricting
"""

!pip install pulp

## Get population data
# imports
from pulp import LpProblem, LpMinimize, LpVariable, lpSum, LpStatus, PULP_CBC_CMD, LpBinary as pulp_LpBinary
import numpy as np
import pandas as pd
import geopandas as gpd
import matplotlib.pyplot as plt
import random
import requests


from google.colab import drive
drive.mount('/content/drive')

# Load population data
file_path = '/content/drive/My Drive/MSDS 460/table-data.csv'
pop_data = pd.read_csv(file_path)
county_population = pop_data.set_index('county')['pop2020'].to_dict()
county_population = {county.replace(' County', ''): population for county, population in county_population.items()}
county_population

# Get lat/long values for each county from openstreetmap.org (google required a paid API key)
import requests
import pandas as pd

def get_lat_long_osm(county_name):
    # Format the URL with the county name
    url = f"https://nominatim.openstreetmap.org/search?q={county_name},+Washington&format=json&limit=1"
    headers = {'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0'}
    response = requests.get(url, headers=headers)
    if response.status_code == 200:
        data = response.json()
        if data:
            lat = data[0]['lat']
            lng = data[0]['lon']
            return pd.Series([lat, lng])
        else:
            return pd.Series([None, None])
    else:
        return pd.Series([None, None])

# Adding lat/long by 'name' column
pop_data[['Latitude', 'Longitude']] = pop_data['name'].apply(get_lat_long_osm)

# output
print(pop_data)

# Distance calculator as provided by Dr. Thomas Miller in the class
import math
from math import pi, pow, sin, cos, asin, sqrt, floor
from scipy import stats
import numpy as np
from pyproj import Proj

def degrees_to_radians(x):
     return((pi/180)*x)

def lon_lat_distance_miles(lon_a,lat_a,lon_b,lat_b):
    radius_of_earth = 24872/(2*pi)
    c = sin((degrees_to_radians(lat_a) - \
    degrees_to_radians(lat_b))/2)**2 + \
    cos(degrees_to_radians(lat_a)) * \
    cos(degrees_to_radians(lat_b)) * \
    sin((degrees_to_radians(lon_a) - \
    degrees_to_radians(lon_b))/2)**2
    return(2 * radius_of_earth * (asin(sqrt(c))))

def lon_lat_distance_meters (lon_a,lat_a,lon_b,lat_b):
    return(lon_lat_distance_miles(lon_a,lat_a,lon_b,lat_b) * 1609.34)

# UTM zone may be computed directly from the list of longitude values
def findZone(listOfLon):
    zones = [ ((floor((long + 180)/6) ) % 60) + 1 for long in listOfLon]
    zone = stats.mode(zones, keepdims = False)[0].astype(int)
    return(zone.item())

print()
print("Glendale to Pasadena distances computed directly from lon/lat:")
print("miles: ",lon_lat_distance_miles(-118.255074 ,34.142509,-118.131943,34.156113))
print("meters: ",lon_lat_distance_meters(-118.255074 ,34.142509,-118.131943,34.156113))

# UTM zones are obtained from longitude measures only
zoneSetting = str(findZone([-118.255074,-118.131943]))

# apLocation data defined by UTM apx and apy and elevation apz coordinates
# apx and apy come from projection of coord_longitude and coord_latitude
myProj = Proj("+proj=utm +zone=" + zoneSetting + " +north +ellps=WGS84 +datum=WGS84 +units=m +no_defs")

GlendaleUTMx, GlendaleUTMy = myProj(-118.255074 ,34.142509)
PasadenaUTMx, PasadenaUTMy = myProj(-118.131943, 34.156113)
UTMdistance = sqrt((GlendaleUTMx - PasadenaUTMx)**2 + (GlendaleUTMy - PasadenaUTMy)**2)
print()
print("Glendale to Pasadena distances computed from UTM projection:")
print("meters: ",UTMdistance)

# use distance functions from above to calculate distance between each county and store it within the dataframe
import pandas as pd
from scipy.spatial.distance import pdist, squareform

def calculate_distances(df):
    df['name'] = df['name'].str.replace(' County', '', regex=False)
    # Convert lat/long to numeric
    df['Longitude'] = pd.to_numeric(df['Longitude'])
    df['Latitude'] = pd.to_numeric(df['Latitude'])

    coordinates = df[['Longitude', 'Latitude']].values
    distances = pdist(coordinates, metric=lambda u, v: lon_lat_distance_miles(u[0], u[1], v[0], v[1]))
    distance_matrix = squareform(distances)
    return pd.DataFrame(distance_matrix, index=df['name'], columns=df['name'])

# Execute function
distance_matrix = calculate_distances(pop_data)
distance_matrix

# Check average distance between counties
average_distance = distance_matrix.values.sum() / (distance_matrix.shape[0] * distance_matrix.shape[1])
print(f"The average distance between counties is: {average_distance} miles")

# Get adjacency data and load it into adjacent_counties df
import requests

# Create dictionary
url = 'https://www2.census.gov/geo/docs/reference/county_adjacency.txt'
resp = requests.get(url)
data = resp.text

adjacent_counties = {}

# Read the adjacency data
for line in data.splitlines():
    tokens = line.split("\t")

    if len(tokens) == 4 and tokens[0]:
        county, state = tokens[0].strip('"').split(',')
        county = ' '.join(part for part in county.split() if part != "County")
        state = state.strip()

        if state == "WA":
            adjacent_counties.setdefault(county, set())

            neighbor, neighbor_state = tokens[2].strip('"').split(',')
            neighbor = ' '.join(part for part in neighbor.split() if part != "County")
            neighbor_state = neighbor_state.strip()

            if neighbor_state == "WA" and neighbor != county:
                adjacent_counties[county].add(neighbor)
                adjacent_counties.setdefault(neighbor, set()).add(county)

    elif len(tokens) == 4:  # Additional neighbors
        if state == "WA":  # Only process if we're still on a WA county
            neighbor, neighbor_state = tokens[2].strip('"').split(',')
            neighbor = ' '.join(part for part in neighbor.split() if part != "County")
            neighbor_state = neighbor_state.strip()

            if neighbor_state == "WA" and neighbor != county:
                adjacent_counties[county].add(neighbor)
                adjacent_counties.setdefault(neighbor, set()).add(county)

# Convert to list
adjacent_counties = {
    county: list(neighbors)
    for county, neighbors in adjacent_counties.items()
}

# Filter external counties
if 'county_population' in locals():
    adjacent_counties = {
        county: [n for n in neighbors if n in county_population]
        for county, neighbors in adjacent_counties.items()
        if county in county_population
    }

print(adjacent_counties)

"""# Optimization Problem
- Develop the model
- Visualization
"""

import pulp
import pandas as pd

# Step 1: Define input Parameters
num_districts = 11  # Number of districts to assign counties to
target_population = sum(county_population.values()) / num_districts  # Target population for each district
population_deviation = target_population * 0.10  # Allowable 10% deviation for population balance (to account for smaller counties)

# Step 2: Set aside King and Pierce counties (Assign them to District 1 and 2 directly)
excluded_counties = ['King', 'Pierce']
district_assignments = {'King': 1, 'Pierce':2}

# Step 3: Define remaining counties after excluding King and Pierce
remaining_counties = {county: population for county, population in county_population.items() if county not in excluded_counties}
remaining_adjacent_counties = {county: neighbors for county, neighbors in adjacent_counties.items() if county not in excluded_counties}

# Step 4: Define Decision Variables for remaining counties (exclude King and Pierce from assignment)
x = pulp.LpVariable.dicts("CountyAssignment",
                          ((county, d) for county in remaining_counties.keys() for d in range(3, num_districts)),  # Start from district 2
                          cat="Binary")

# Step 5: Create deviation variables for positive and negative deviations for each district
deviation_pos = pulp.LpVariable.dicts("DeviationPos", range(3, num_districts), lowBound=0, cat="Continuous")
deviation_neg = pulp.LpVariable.dicts("DeviationNeg", range(3, num_districts), lowBound=0, cat="Continuous")


# Step 6: Create distance penalty variables
distance_penalty = pulp.LpVariable.dicts("DistancePenalty",
                                       ((county1, county2, d)
                                        for county1 in remaining_counties
                                        for county2 in remaining_counties
                                        for d in range(3, num_districts)
                                        if county1 < county2),
                                       lowBound=0, cat="Continuous")

# Step 7: Create the Problem
prob = pulp.LpProblem("Redistricting_Problem", pulp.LpMinimize)

# Step 8: Define Objective Function (Minimize the sum of deviations)
# Set weights for population and distance
population_weight = 1.0
distance_weight = 0.70

objective = (population_weight * pulp.lpSum([deviation_pos[d] + deviation_neg[d]
                                           for d in range(3, num_districts)]) +
            distance_weight * pulp.lpSum([distance_penalty[county1, county2, d]
                                        for county1 in remaining_counties
                                        for county2 in remaining_counties
                                        for d in range(3, num_districts)
                                        if county1 < county2]))
prob += objective

# Step 9: Setup Constraints

# 9.1. Each county must be assigned to exactly one district
for county in remaining_counties:
    prob += pulp.lpSum([x[county, d] for d in range(3, num_districts)]) == 1, f"OneDistrictPerCounty_{county}"

# 9.2. Population balance constraint
for d in range(3, num_districts):
    prob += (pulp.lpSum([remaining_counties[county] * x[county, d]
                        for county in remaining_counties.keys()]) ==
            target_population + deviation_pos[d] - deviation_neg[d], f"PopulationBalance_{d}")

# 9.3. Distance penalty constraints (penalty is issued when a non-adjacent county is > 115 miles if they are assigned to the same district)
MAX_DISTANCE = 115
for d in range(3, num_districts):
    for county1 in remaining_counties:
        for county2 in remaining_counties:
            if county1 < county2:
                # Skip if counties are adjacent
                if county2 in remaining_adjacent_counties.get(county1, []):
                    continue

                distance = distance_matrix.loc[county1, county2]
                if distance > MAX_DISTANCE:
                    # Penalize distances over the maximum set 115
                    prob += (distance_penalty[county1, county2, d] >=
                           (distance - MAX_DISTANCE) * (x[county1, d] + x[county2, d] - 1),
                           f"DistancePenalty_{county1}_{county2}_{d}")


# Step 10: Solve the Problem
prob.solve()

# Step 11: Get the Results for remaining counties and assign King/Pierce explicitly
for county in remaining_counties:
    for d in range(3, num_districts):
        if pulp.value(x[county, d]) == 1:
            district_assignments[county] = d

# Step 12: Group counties by district
district_groups = {}
for county, district in district_assignments.items():
    if district not in district_groups:
        district_groups[district] = []
    district_groups[district].append(county)

# Step 13: Prepare results for DataFrame
results = []
for district, counties in district_groups.items():
    total_pop = sum(county_population[county] for county in counties)
    results.append({
        'District': district,
        'Counties': ', '.join(counties),
        'Total Population': total_pop
    })

# Step 14: Create DataFrame to display results
district_assignments_df = pd.DataFrame(results)

district_assignments_df = district_assignments_df.sort_values(by=['District'])

# Step 15: Display the DataFrame
district_assignments_df

"""Create a Map of the Redistribution in Washington"""

# Create a map of Washington State with each county colored by their new district
import geopandas as gpd
import matplotlib.pyplot as plt
import seaborn as sns

# Get unique districts based on the dataframe
districts = district_assignments_df['District'].unique()

# GeoJSON URL for the counties
geojson_url = 'https://raw.githubusercontent.com/plotly/datasets/master/geojson-counties-fips.json'

# Load the GeoJSON data into a GeoDataFrame
counties = gpd.read_file(geojson_url)

# Filter for Washington State (STATEFP = '53' is for Washington)
washington_counties = counties[counties['STATE'] == '53']

# Generate color mapping for districts using seaborn's color palette
colors = sns.color_palette("Set3", n_colors=len(districts)).as_hex()

# Add district column and initialize to 0 (no district assigned yet)
washington_counties['district'] = 0

# Create a dictionary for district to color mapping
district_color_map = {district: colors[i] for i, district in enumerate(districts)}

# Iterate through the district assignments DataFrame
for i in range(len(district_assignments_df)):
    # Get the counties in the current district
    counties_in_district = district_assignments_df.loc[i, 'Counties'].split(', ')
    # Iterate through the counties in the district
    for county_name in counties_in_district:
        # Find matching counties in the GeoDataFrame
        matching_county = washington_counties['NAME'].str.contains(county_name, case=False, na=False)
        # Assign the district number to the matching counties
        district_number = district_assignments_df.loc[i, 'District']
        washington_counties.loc[matching_county, 'district'] = district_number
# Assign colors based on districts using the district_color_map
washington_counties['color'] = washington_counties['district'].map(district_color_map).fillna('lightgrey')

# Plot map
fig, ax = plt.subplots(figsize=(18, 12))
washington_counties.plot(ax=ax, edgecolor='black', color=washington_counties['color'])

# Add labels for counties
for x, y, label in zip(washington_counties.geometry.centroid.x,
                       washington_counties.geometry.centroid.y,
                       washington_counties['NAME']):
    ax.text(x, y, label, fontsize=8, ha='center')

# Legend
handles = [plt.Rectangle((0, 0), 1, 1, color=district_color_map[district]) for district in districts]
ax.legend(handles, [f'District {d}' for d in districts], title="Districts", loc='lower left')

# Title
ax.set_title('Counties of Washington State by District', fontsize=15)

plt.show()

"""Check that all counties (39) in Washington are accounted for each district"""

population_by_district = district_assignments_df.copy()

# Calculate population for each district
for index, row in population_by_district.iterrows():
  counties = row['Counties'].split(', ')
  total_pop = sum(county_population.get(county, 0) for county in counties)
  population_by_district.loc[index, 'Total Population'] = total_pop

print(population_by_district[['District', 'Total Population']])